<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CORS Proxy Cache Builder</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #121212;
            color: #e0e0e0;
        }
        h1, h2 {
            color: #4dd0e1;
        }
        pre {
            background-color: #1a1a1a;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            white-space: pre-wrap;
        }
        button {
            background-color: #4dd0e1;
            color: #121212;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px 0;
        }
        button:hover {
            background-color: #26c6da;
        }
        #progress {
            margin-top: 20px;
            height: 20px;
            background-color: #1a1a1a;
            border-radius: 10px;
            overflow: hidden;
        }
        #progress-bar {
            height: 100%;
            background-color: #4dd0e1;
            width: 0%;
            transition: width 0.3s;
        }
        #log {
            height: 300px;
            overflow-y: auto;
            margin-top: 20px;
            padding: 10px;
            background-color: #1a1a1a;
            border-radius: 5px;
            font-family: monospace;
        }
        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }
        .stat-box {
            background-color: #1a1a1a;
            padding: 15px;
            border-radius: 5px;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #4dd0e1;
        }
    </style>
</head>
<body>
    <h1>CORS Proxy Cache Builder</h1>
    <p>This tool helps build a cache of VRChat API images by using a CORS proxy.</p>

    <div class="stats">
        <div class="stat-box">
            <div>Images Processed</div>
            <div class="stat-value" id="processed-count">0</div>
        </div>
        <div class="stat-box">
            <div>Successfully Cached</div>
            <div class="stat-value" id="success-count">0</div>
        </div>
    </div>

    <div id="progress">
        <div id="progress-bar"></div>
    </div>

    <button id="build-cache">Build Cache with Proxy</button>
    <button id="check-cache">Check Cache Status</button>
    <button id="clear-cache">Clear Cache</button>
    <button id="back">Back to Website</button>

    <h2>Log</h2>
    <div id="log"></div>

    <script>
        // Buttons
        document.getElementById('build-cache').addEventListener('click', buildCache);
        document.getElementById('check-cache').addEventListener('click', checkCache);
        document.getElementById('clear-cache').addEventListener('click', clearCache);
        document.getElementById('back').addEventListener('click', () => {
            window.location.href = 'support.html';
        });

        // Stats elements
        const processedCountEl = document.getElementById('processed-count');
        const successCountEl = document.getElementById('success-count');
        const progressBarEl = document.getElementById('progress-bar');

        // Logging function
        function log(message, color = '#e0e0e0') {
            const logElement = document.getElementById('log');
            const entry = document.createElement('div');
            entry.innerHTML = `<span style="color: ${color}">[${new Date().toLocaleTimeString()}] ${message}</span>`;
            logElement.appendChild(entry);
            logElement.scrollTop = logElement.scrollHeight;
        }

        // Function to check cache status
        function checkCache() {
            try {
                const cachedImageData = localStorage.getItem('fishCommunityImages');
                const cachedTimestamp = localStorage.getItem('fishCommunityImagesTimestamp');

                if (!cachedImageData || !cachedTimestamp) {
                    log('No cache found. Use "Build Cache" to create one.', '#FF5722');
                    return;
                }

                const timestamp = parseInt(cachedTimestamp, 10);
                const now = Date.now();
                const ageInHours = Math.floor((now - timestamp) / (60 * 60 * 1000));

                const parsedData = JSON.parse(cachedImageData);
                const imageCount = Object.keys(parsedData).length;
                const imagesWithDataUrl = Object.values(parsedData).filter(img => img.dataUrl).length;
                const corsBlocked = Object.values(parsedData).filter(img => img.corsBlocked).length;
                const cacheSize = new Blob([cachedImageData]).size / (1024 * 1024); // Size in MB

                log(`Cache status:`, '#4CAF50');
                log(`- Age: ${ageInHours} hours old`);
                log(`- Total images: ${imageCount}`);
                log(`- Images with data URLs: ${imagesWithDataUrl}`);
                log(`- CORS-blocked images: ${corsBlocked}`);
                log(`- Cache size: ${cacheSize.toFixed(2)} MB`);

                // Update stats
                processedCountEl.textContent = imageCount;
                successCountEl.textContent = imagesWithDataUrl;

            } catch (e) {
                log(`Error checking cache: ${e.message}`, '#FF5722');
            }
        }

        // Function to clear the cache
        function clearCache() {
            try {
                localStorage.removeItem('fishCommunityImages');
                localStorage.removeItem('fishCommunityImagesTimestamp');
                log('Cache cleared successfully', '#4CAF50');

                // Reset stats
                processedCountEl.textContent = '0';
                successCountEl.textContent = '0';
                progressBarEl.style.width = '0%';

            } catch (e) {
                log(`Error clearing cache: ${e.message}`, '#FF5722');
            }
        }

        // Function to build the cache using a CORS proxy
        async function buildCache() {
            log('Starting cache build process...', '#4CAF50');

            try {
                // First, fetch the community data to get image URLs
                log('Fetching community data...');
                try {
                    // Use the correct URL for community data
                    let response;
                    try {
                        // Try the gist URL that's used in the actual website
                        log('Trying to fetch from gist URL...');
                        response = await fetch('https://gist.githubusercontent.com/TheZiver/9fdd3f8c495098ffa0beceece373d382/raw');
                    } catch (e) {
                        // If that fails, try the website URL
                        log('Gist URL failed, trying website URL...');
                        response = await fetch('https://theziver.github.io/data/community_groups.json');
                    }
                    const text = await response.text();

                    // Log the first few characters to debug
                    log(`Received data (first 100 chars): ${text.substring(0, 100)}...`);

                    // Try to parse the JSON, handling any BOM characters
                    let data;
                    try {
                        // First try direct parsing
                        data = JSON.parse(text);
                    } catch (parseError) {
                        // If that fails, try removing BOM character if present
                        log('Initial JSON parse failed, trying to remove BOM character...', '#FF9800');
                        const cleanText = text.replace(/^\ufeff/, '');
                        data = JSON.parse(cleanText);
                    }

                    let imageUrls = [];

                    // Extract image URLs from community data
                    if (data.community_groups) {
                        log(`Found ${data.community_groups.length} community groups`);

                        // Filter out groups with SYSTEM tag
                        const filteredGroups = data.community_groups.filter(group =>
                            !group.tags || !group.tags.includes('SYSTEM')
                        );

                        log(`Processing ${filteredGroups.length} groups (excluding SYSTEM groups)`);

                        // Extract image URLs and status
                        imageUrls = filteredGroups.map(group => ({
                            url: group.icon_url, // Use icon_url from the new JSON structure
                            status: group.tags && group.tags.includes('FISH_VERIFIED') ? 'FISH_VERIFIED' :
                                   group.tags && group.tags.includes('FISH_CERTIFIED') ? 'FISH_CERTIFIED' :
                                   group.tags && group.tags.includes('FISH') ? 'FISH' : 'FISH_KNOWN',
                            name: group.group_name || 'Unknown Group' // Use group_name from the new JSON structure
                        }));
                    } else {
                        log('Using old JSON structure', '#FF9800');
                        imageUrls = data.map(group => ({
                            url: group.imageUrl,
                            status: group.status || 'FISH_KNOWN',
                            name: group.name || 'Unknown Group'
                        }));
                    }
                } catch (jsonError) {
                    log(`Error parsing JSON: ${jsonError.message}`, '#FF5722');
                    log('Trying alternative approach with hardcoded URLs...', '#FF9800');

                    // Fallback to a few hardcoded VRChat URLs for testing
                    imageUrls = [
                        { url: 'https://i.imgur.com/XqYGMFZ.png', status: 'FISH_VERIFIED', name: 'Test Image 1' },
                        { url: 'https://i.imgur.com/JvS5tn7.png', status: 'FISH_CERTIFIED', name: 'Test Image 2' },
                        { url: 'https://i.imgur.com/TZ9TQZd.png', status: 'FISH', name: 'Test Image 3' }
                    ];
                }

                // Filter out items without URLs
                imageUrls = imageUrls.filter(item => item.url);

                log(`Found ${imageUrls.length} image URLs to process`);

                // Initialize cache object
                const preloadedImages = {};

                // Process images
                let processedCount = 0;
                let successCount = 0;

                // Function to process a single image
                async function processImage(item) {
                    try {
                        log(`Processing: ${item.name} (${item.status})`);

                        // Create a proxied URL to bypass CORS
                        const proxiedUrl = `https://corsproxy.io/?${encodeURIComponent(item.url)}`;

                        // Load the image
                        const img = new Image();
                        img.crossOrigin = 'anonymous';

                        // Wait for the image to load
                        await new Promise((resolve, reject) => {
                            img.onload = resolve;
                            img.onerror = () => {
                                log(`Failed to load: ${item.url}`, '#FF5722');
                                reject(new Error('Image load failed'));
                            };
                            img.src = proxiedUrl;
                        });

                        // Resize the image to 128×128
                        const canvas = document.createElement('canvas');
                        canvas.width = 128;
                        canvas.height = 128;
                        const ctx = canvas.getContext('2d');

                        // Use high-quality resizing
                        ctx.imageSmoothingEnabled = true;
                        ctx.imageSmoothingQuality = 'high';
                        ctx.drawImage(img, 0, 0, 128, 128);

                        // Get data URL
                        const dataUrl = canvas.toDataURL('image/png', 0.9);

                        // Store in cache object
                        preloadedImages[item.url] = {
                            loaded: true,
                            status: item.status,
                            name: item.name,
                            timestamp: Date.now(),
                            dataUrl: dataUrl
                        };

                        log(`Successfully cached: ${item.name}`, '#4CAF50');
                        successCount++;
                        successCountEl.textContent = successCount;

                        return true;
                    } catch (e) {
                        log(`Error processing ${item.url}: ${e.message}`, '#FF5722');

                        // Still cache metadata
                        preloadedImages[item.url] = {
                            loaded: true,
                            status: item.status,
                            name: item.name,
                            timestamp: Date.now(),
                            corsBlocked: true
                        };

                        return false;
                    } finally {
                        processedCount++;
                        processedCountEl.textContent = processedCount;

                        // Update progress bar
                        const progress = (processedCount / imageUrls.length) * 100;
                        progressBarEl.style.width = `${progress}%`;
                    }
                }

                // Process images in batches to avoid overwhelming the browser
                const BATCH_SIZE = 5;

                for (let i = 0; i < imageUrls.length; i += BATCH_SIZE) {
                    const batch = imageUrls.slice(i, i + BATCH_SIZE);
                    log(`Processing batch ${Math.floor(i/BATCH_SIZE) + 1} of ${Math.ceil(imageUrls.length/BATCH_SIZE)}`);

                    // Process batch in parallel
                    await Promise.all(batch.map(processImage));

                    // Small delay between batches
                    await new Promise(resolve => setTimeout(resolve, 500));
                }

                // Save to localStorage
                try {
                    localStorage.setItem('fishCommunityImages', JSON.stringify(preloadedImages));
                    localStorage.setItem('fishCommunityImagesTimestamp', Date.now().toString());

                    log(`Cache build complete! Processed ${processedCount} images, successfully cached ${successCount}`, '#4CAF50');
                    log(`Cache size: ${(new Blob([JSON.stringify(preloadedImages)]).size / (1024 * 1024)).toFixed(2)} MB`);
                } catch (e) {
                    log(`Error saving to localStorage: ${e.message}`, '#FF5722');

                    if (e.name === 'QuotaExceededError') {
                        log('Storage quota exceeded. Trying to save a reduced version...', '#FF9800');

                        // Create a reduced version without some data URLs
                        const entries = Object.entries(preloadedImages);
                        entries.sort((a, b) => a[1].timestamp - b[1].timestamp);

                        // Remove data URLs from oldest entries until it fits
                        let currentSize = new Blob([JSON.stringify(preloadedImages)]).size / (1024 * 1024);
                        let removedCount = 0;

                        for (const [url, data] of entries) {
                            if (currentSize <= 4 || removedCount >= entries.length / 2) break;

                            if (data.dataUrl) {
                                const beforeSize = JSON.stringify(preloadedImages).length;
                                delete preloadedImages[url].dataUrl;
                                preloadedImages[url].corsBlocked = true;
                                const afterSize = JSON.stringify(preloadedImages).length;

                                currentSize -= (beforeSize - afterSize) / (1024 * 1024);
                                removedCount++;
                            }
                        }

                        try {
                            localStorage.setItem('fishCommunityImages', JSON.stringify(preloadedImages));
                            localStorage.setItem('fishCommunityImagesTimestamp', Date.now().toString());

                            log(`Saved reduced cache with ${successCount - removedCount} data URLs`, '#4CAF50');
                        } catch (e2) {
                            log(`Failed to save reduced cache: ${e2.message}`, '#FF5722');
                        }
                    }
                }

            } catch (e) {
                log(`Error building cache: ${e.message}`, '#FF5722');
                log(`Stack trace: ${e.stack}`, '#FF5722');
            }
        }

        // Check cache status on page load
        checkCache();
    </script>
</body>
</html>
